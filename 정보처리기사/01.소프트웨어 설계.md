# 목차
* 요구사항 확인
    * [소프트웨어 생명주기](https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EC%86%8C%ED%94%84%EB%A5%B4%EC%9B%A8%EC%96%B4-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-software-life-cycle)
        * Waterfall Model
        * Prototype Model
        * Spiral Model
        * Agile Model
    * Scrum 기법
    * XP 기법
    * UML
        * Things
        * Relationships
        * Association
        * Aggregation
        * Composition
        * Generalization
        * Dependency
        * Realization
    * Diagram
        * Structural Diagram
        * Behaviroal Diagram
    * Use Case Diagram
    * Class Diagram
    * Sequence Diagram
* 화면 설계 
* 애플리케이션 설계
* 인터페이스 설계


## 요구사항 확인

### 소프르웨어 생명주기 (Software Life Cycle)

* **Waterfall Model(폭포수 모형)** 
    <br/>
    전통적인 생명주기 모형 <br/>
    한 단계가 끝난 후 다음 단계로 넘어갈 수 있음 (= **선형 순차적 모형**) <br/>
    순차적으로 진행 됨 <br/>
    중간에 새 요구사항이 반영되지 않아 고객의 요구가 정확할 때 진행
    

    ![폭포수 모형](https://user-images.githubusercontent.com/90914001/155743287-a9d48178-2bf4-4a8b-8518-d8269a15f822.PNG)

    <br/>

* **Prototype Model(프로토타입 모형 = 원형 모형)** 
    <br/>
    변경이 용이해 고객의 요구사항이 부정확할 때 진행 <br/>
    견본품(prototype)을 만들어 최종 결과물을 예측 <br/>
    
    ![프로토타입 모형](https://user-images.githubusercontent.com/90914001/155713613-4a028a41-6769-4d12-91ab-240d6ce9c31d.PNG)

    <br/>

* **Spiral Model(나선형 모형 = 점진적 모형)** 
    <br/>
    비용이 많이 들고, 대규모 프로젝트에 적합 <br/>
    여러 번의 소프트웨어 개발 과정을 거쳐 추가 요구사항 보완 가능 <br/>
    유지보수 과정 필요 없음 <br/>

    ![나선형 모형](https://user-images.githubusercontent.com/90914001/155741779-fae86fa1-b6e6-47db-8a30-e4113fb57fa6.PNG)

* **Agile Model(애자일 모형)**
    <br/>
    고객과의 소통에 초점을 맞춘 방법론 <br/>
    고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행 <br/>
    소규모 프로젝트에 적합 <br/>
    요구사항에 우선순위 부여함 <br/>
    
    ![애자일 모형](https://user-images.githubusercontent.com/90914001/155885981-5adc28b8-3772-442d-be42-aaa31149d198.PNG)
    
    **[애자일 기반 소프트웨어 개발 모형]**
    * [Scrum(스크럼)]
    * [XP(eXtreme Programming)]
    * Kanban(칸반)
    * Lean
    * Crystal(크리스탈)
    * ASD
    * FDD(기능 중심 개발)
    * DSDM
    * DAD

      ⁞  

## Scrum(스크럼) 기법
팀 중심으로 개발의 효율성을 높임 <br/>
팀원 스스로가 팀을 구성해 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 한다.

* **팀 구성** 
    * 제품 책임자(PO)
    * 스크럼 마스터(SM)
    * 개발팀(DT)

* **개발 프로세스**
    * 제품 백로그 → 스프린트 계획 회의 → 스프린트 → 일일 스크럼 회의 → 스프린트 검토 회의 → 스프린트 회고 

## XP (eXtreme Programming) 기법
짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠르게 소프트웨어를 개발한다. <br/>
릴리즈 테스트마다 고객을 직접 참여시킨다. <br/>

* **XP 5가지 핵심 가치**
    <br/>
    * 의사소통(Communication)
    * 단순성(Simplicity)
    * 용기(Courage)
    * 존중(Respect)
    * 피드백(Feedback)

* **개발 프로세스**
    * 사용자 스토리(User Story)
    * 릴리즈 계획 수립(Release Planning)
    * 스파이크(Spike)
    * 이터레이션(Iteraion)
    * 승인 검사(Acceptance Test, = 인수 테스트)
    * 소규모 릴리즈(Small Release)

* **XP 주요 실천 방법(Practice)**
    | 실천방법          |  내용         |
    | ----------------- | ------------ |
    | **Pair Programming** <br/> (짝 프로그래밍)| 다른 사람과 함께 프로그래밍을 수행, 개발에 대한 책임을 공동으로 나눠 가진다. |
    | **Collective Ownershi** <br/> (공동 코드 소유) | 개발 코드에 대한 권한과 책을을 공동으로 소유한다. |
    | Test-Driven Development <br/> (테스트 주도 개발) | 실제 코드를 작성하기 전 테스트 케이스를 먼저 작성해 자신이 해야할 것이 무엇인지 파악한다. <br/> 지속적으로 테스트 할 수 있도록 자동화된 테스팅 도구(구조 프레임워크)를 사용한다. |  
    | Whole Team <br/> (전체 팀) | 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 한다. |
    | **Continuous Integration** <br/> (계속적인 통합) | 모듈 단위로 나눠 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합된다. |
    | Design Improvement <br/> (디자인 개선) <br/> or <br/> Refactoring <br/> (리팩토링) | 프로그램 기능의 변경 없이 단순화, 유연성 강화 등을 통해 시스템을 재구성 한다. |
    | Small Releases <br/> (소규모 릴리즈) | 릴리즈 기간을 짧게 반복해 고객의 요구 변화에 신속히 대응할 수 있다. |

## UML (Unified Modeling Language)
사용자와 개발자간의 원활한 의사소통을 위한 대표적인 객체지향 모델링 언어 
<br/>

* **모델링 언어?** 
    <br/>
    만들고자 하는 것을 시각적으로 표현할 수 있는 표기법/도구

* **구성요소**
    * 사물 (Things)
    * 관계 (Relationships)
    * 다이어그램(Diagram)

### 사물(Things)
다이어그램 안에서 관계가 형성될 수 있는 대상

| 사물                    | 내용                                  |
| ----------------------- | ------------------------------------ |
| 구조 사물 (Structural Things) | 시스템의 개념적, 물리적 요소 표현 <br/> Class, Use Case, Component, Node ... |
| 행동 사물 (Behavioral Things) | 시간과 공간에 따른 요소들의 행위 표현 <br/> 상호작용(Interaction), 상태 머신(State Machine) ... |
| 그룹 사물 (Grouping Things)   | 요소들을 그룹으로 묶어 표현 <br/> Package |
| 주해 사물 (Annotation Things) | 부가적인 설명/제약조건 표현 <br/> Note |

* Component (컴포넌트) : 문서, 소스코드, 파일, 라이브러리 등과 같은 모듈화된 자원, 재사용 가능

### 관계(Relationships)
사물과 사물사이의 연관성 표현

#### 연관(Association) 관계
2개 이상의 사물 사이를 실선으로 연결, 화살표로 방향성 표현 <br/>
양방향 관계일 경우 실선으로만 연결 <br/>

#### 집합(Aggregation) 관계
하나의 사물이 다른 사물에 포함된 관계이며 서로 독립적 <br/>

> 포함되는 쪽(부분, Part) ㅡ◇ 포함하는 쪽(전체, Whole) <br/> 
  ex) 프린터 ㅡ◇ 컴퓨터

#### 포함(Composition) 관계
서로 독립될 수 없고 생명주기를 함께한다. <br/>

> 포함되는 쪽(부분, Part) ㅡ◆ 포함하는 쪽(전체, Whole) <br/>
  ex) 열쇠 ㅡ◆ 문

#### 일반화(Generalization) 관계
하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다. <br/>

> 구체적인 개념(하위, 자식) ⇾ 일반적인 개념(상위, 부모) <br/>
  ex) 아메리카노 ⇾ 커피 

#### 의존(Dependency) 관계
사물 서로 연관은 있지만 필요에 의해 짧은 시간동안만 연관을 유지하는 관계를 표현한다. <br/>

> 영향 주는 사물(이용자) ⇢ 영향 받는 사물(제공자) <br/>
  ex) 등급 ⇢ 할인율

#### 실체화(Realization) 관계
사물이 할 수 있거나 해야하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다. <br/>

> 사물 ---▹ 기능 <br/>
  ex) 비행기 ---▹ 날 수 있는 ◃--- 새

