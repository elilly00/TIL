<details> 
    <summary>목차 </summary>
        <ul>
            <li>요구사항 확인</li>
                <ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EC%86%8C%ED%94%84%EB%A5%B4%EC%9B%A8%EC%96%B4-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-software-life-cycle">소프트웨어 생명주기</a></li>
                        <ul>
                            <li>Waterfall Model</li>
                            <li>Prototype Model</li>
                            <li>Spiral Model</li>
                            <li>Agile Model</li>
                        </ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#scrum%EC%8A%A4%ED%81%AC%EB%9F%BC-%EA%B8%B0%EB%B2%95">Scrum 기법</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#xp-extreme-programming-%EA%B8%B0%EB%B2%95">XP 기법</a></li>
                    <li><a herf="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#uml-unified-modeling-language">UML</a></li>
                        <ul>
                            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EC%82%AC%EB%AC%BCthings">Things</a></li>
                            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EA%B4%80%EA%B3%84relationships">Relationships</a></li>
                                <ul>
                                    <li>Association</li>
                                    <li>Aggregation</li>
                                    <li>Composition</li>
                                    <li>Generalization</li>
                                    <li>Dependency</li>
                                    <li>Realization</li>
                                </ul>
                        </ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8diagram">Diagram</a></li>
                        <ul>
                            <li>Structural Diagram</li>
                            <li>Behaviroal Diagram</li>
                        </ul>
                    <li>Use Case Diagram</li>
                    <li>Class Diagram</li>
                    <li>Sequence Diagram</li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D">요구사항 분석</a></li>
                <ul>
                    <li>DFD(자료 흐름도)</li>
                </ul>       
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5object-oriented">객체지향(Object-Oriented)</a></li>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%B6%84%EC%84%9D-%EB%B0%8F-%EC%84%A4%EA%B3%84">객체지향 분석 및 설계</a></li>
                <ul>
                    <li>방법론</li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EB%AA%A8%EB%93%88module">모듈(Module)</a></li>
                <ul>
                    <li>결합도</li>
                    <li>응집도</li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4">디자인 패턴</a></li>
                <ul>
                    <li>GoF 디자인 패턴 유형</li>
                </ul>
        </ul>
</details>
<div markdown="1">

## 요구사항 확인

### 소프르웨어 생명주기 (Software Life Cycle)

* **Waterfall Model(폭포수 모형)** 
    <br/>
    전통적인 생명주기 모형 <br/>
    한 단계가 끝난 후 다음 단계로 넘어갈 수 있음 (= **선형 순차적 모형**) <br/>
    순차적으로 진행 됨 <br/>
    중간에 새 요구사항이 반영되지 않아 고객의 요구가 정확할 때 진행

    ![폭포수 모형](https://user-images.githubusercontent.com/90914001/155743287-a9d48178-2bf4-4a8b-8518-d8269a15f822.PNG)

    <br/>

* **Prototype Model(프로토타입 모형 = 원형 모형)** 
    <br/>
    변경이 용이해 고객의 요구사항이 부정확할 때 진행 <br/>
    견본품(prototype)을 만들어 최종 결과물을 예측 <br/>
    
    ![프로토타입 모형](https://user-images.githubusercontent.com/90914001/155713613-4a028a41-6769-4d12-91ab-240d6ce9c31d.PNG)

    <br/>

* **Spiral Model(나선형 모형 = 점진적 모형)** 
    <br/>
    비용이 많이 들고, 대규모 프로젝트에 적합 <br/>
    여러 번의 소프트웨어 개발 과정을 거쳐 추가 요구사항 보완 가능 <br/>
    유지보수 과정 필요 없음 <br/>

    ![나선형 모형](https://user-images.githubusercontent.com/90914001/155741779-fae86fa1-b6e6-47db-8a30-e4113fb57fa6.PNG)

* **Agile Model(애자일 모형)**
    <br/>
    고객과의 소통에 초점을 맞춘 방법론 <br/>
    고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행 <br/>
    소규모 프로젝트에 적합 <br/>
    요구사항에 우선순위 부여함 <br/>
    
    ![애자일 모형](https://user-images.githubusercontent.com/90914001/155885981-5adc28b8-3772-442d-be42-aaa31149d198.PNG)
    
    **[애자일 기반 소프트웨어 개발 모형]**
    * [Scrum(스크럼)](https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#scrum%EC%8A%A4%ED%81%AC%EB%9F%BC-%EA%B8%B0%EB%B2%95)
    * [XP(eXtreme Programming)](https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/01.%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84.md#xp-extreme-programming-%EA%B8%B0%EB%B2%95)
    * Kanban(칸반)
    * Lean
    * Crystal(크리스탈)
    * ASD
    * FDD(기능 중심 개발)
    * DSDM
    * DAD

      ⁞  

## Scrum(스크럼) 기법
팀 중심으로 개발의 효율성을 높임 <br/>
팀원 스스로가 팀을 구성해 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 한다.

* **팀 구성** 
    * 제품 책임자(PO)
    * 스크럼 마스터(SM)
    * 개발팀(DT)

* **개발 프로세스**
    * 제품 백로그 → 스프린트 계획 회의 → 스프린트 → 일일 스크럼 회의 → 스프린트 검토 회의 → 스프린트 회고 

## XP (eXtreme Programming) 기법
짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠르게 소프트웨어를 개발한다. <br/>
릴리즈 테스트마다 고객을 직접 참여시킨다. <br/>

* **XP 5가지 핵심 가치**
    <br/>
    * 의사소통(Communication)
    * 단순성(Simplicity)
    * 용기(Courage)
    * 존중(Respect)
    * 피드백(Feedback)

* **개발 프로세스**
    * 사용자 스토리(User Story)
    * 릴리즈 계획 수립(Release Planning)
    * 스파이크(Spike)
    * 이터레이션(Iteraion)
    * 승인 검사(Acceptance Test, = 인수 테스트)
    * 소규모 릴리즈(Small Release)

* **XP 주요 실천 방법(Practice)**
    | 실천방법          |  내용         |
    | ----------------- | ------------ |
    | **Pair Programming** <br/> (짝 프로그래밍)| 다른 사람과 함께 프로그래밍을 수행, 개발에 대한 책임을 공동으로 나눠 가짐 |
    | **Collective Ownershi** <br/> (공동 코드 소유) | 개발 코드에 대한 권한과 책을을 공동으로 소유 |
    | Test-Driven Development <br/> (테스트 주도 개발) | 실제 코드를 작성하기 전 테스트 케이스를 먼저 작성해 자신이 해야할 것이 무엇인지 파악 <br/> 지속적으로 테스트 할 수 있도록 자동화된 테스팅 도구(구조 프레임워크)를 사용 |  
    | Whole Team <br/> (전체 팀) | 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임 가짐 |
    | **Continuous Integration** <br/> (계속적인 통합) | 모듈 단위로 나눠 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨 |
    | Design Improvement <br/> (디자인 개선) <br/> or <br/> Refactoring <br/> (리팩토링) | 프로그램 기능의 변경 없이 단순화, 유연성 강화 등을 통해 시스템을 재구성 |
    | Small Releases <br/> (소규모 릴리즈) | 릴리즈 기간을 짧게 반복해 고객의 요구 변화에 신속히 대응 가능 |

## UML (Unified Modeling Language)
사용자와 개발자간의 원활한 의사소통을 위한 대표적인 객체지향 모델링 언어 
<br/>

* **모델링 언어?** 
    <br/>
    만들고자 하는 것을 시각적으로 표현할 수 있는 표기법/도구

* **구성요소**
    * 사물 (Things)
    * 관계 (Relationships)
    * 다이어그램(Diagram)

### 사물(Things)
다이어그램 안에서 관계가 형성될 수 있는 대상

| 사물                    | 내용                                  |
| ----------------------- | ------------------------------------ |
| 구조 사물 (Structural Things) | 시스템의 개념적, 물리적 요소 표현 <br/> Class, Use Case, Component, Node ... |
| 행동 사물 (Behavioral Things) | 시간과 공간에 따른 요소들의 행위 표현 <br/> 상호작용(Interaction), 상태 머신(State Machine) ... |
| 그룹 사물 (Grouping Things)   | 요소들을 그룹으로 묶어 표현 <br/> Package |
| 주해 사물 (Annotation Things) | 부가적인 설명/제약조건 표현 <br/> Note |

* Component (컴포넌트) : 문서, 소스코드, 파일, 라이브러리 등과 같은 모듈화된 자원, 재사용 가능

### 관계(Relationships)
사물과 사물사이의 연관성 표현

#### 연관(Association) 관계
2개 이상의 사물 사이를 실선으로 연결, 화살표로 방향성 표현 <br/>
양방향 관계일 경우 실선으로만 연결 <br/>

#### 집합(Aggregation) 관계
하나의 사물이 다른 사물에 포함된 관계이며 서로 독립적 <br/>

> 포함되는 쪽(부분, Part) ㅡ◇ 포함하는 쪽(전체, Whole) <br/> 
  ex) 프린터 ㅡ◇ 컴퓨터

#### 포함(Composition) 관계
서로 독립될 수 없고 생명주기를 함께한다. <br/>

> 포함되는 쪽(부분, Part) ㅡ◆ 포함하는 쪽(전체, Whole) <br/>
  ex) 열쇠 ㅡ◆ 문

#### 일반화(Generalization) 관계
하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다. <br/>

> 구체적인 개념(하위, 자식) ⇾ 일반적인 개념(상위, 부모) <br/>
  ex) 아메리카노 ⇾ 커피 

#### 의존(Dependency) 관계
사물 서로 연관은 있지만 필요에 의해 짧은 시간동안만 연관을 유지하는 관계를 표현한다. <br/>

> 영향 주는 사물(이용자) ⇢ 영향 받는 사물(제공자) <br/>
  ex) 등급 ⇢ 할인율

#### 실체화(Realization) 관계
사물이 할 수 있거나 해야하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다. <br/>

> 사물 ---▹ 기능 <br/>
  ex) 비행기 ---▹ 날 수 있는 ◃--- 새

### 다이어그램(Diagram)
사물과 관계를 도형으로 표현한 것

* 구조적(정적) 다이어그램 (Structural Diagram)

    | 다이어그램 | 내용 |
    | ---------- | -----| 
    | Class Diagram <br/> (클래스 다이어그램) | 시스템의 구조를 파악하고 구조상의 문제점 도출 가능 |
    | Object Diagram <br/> (객체 다이어그램)  | 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델리에 활용 |
    | Component Diagram <br/> (컴포넌트 다이어그램) | 구현 단계에서 사용되는 다이어그램 |
    | Deployment Diagram <br/> (배치 다이어그램) | 노드와 의사소통(통신) 경로로 표현 <br/> 구현 단계에서 사용되는 다이어그램 | 
    | Composite Structrue Diagram <br/> (복합체 구조 다이어그램) | 클래스나 컴포넌트가 복합 구조를 갖는 경우 해당 내부 구조 표현 | 
    | Package Diagram <br/> (패키지 다이어그램) | 유스케이스나 클래스 등 모델 요소들을 그룹화한 패키지들의 관계 표현 |

## 요구사항 분석
사용자 요구의 타당성 조사

사용자 요구 추출해 목표를 정하고 어떤 방식으로 해결할 것인지 결정

요구사항을 정확하고 일관성있게 분석한 후 문서화

### DFD(자료 흐름도)
* Process(프로세스) : 원 / 둥근 사각형
* Data Flow(자료 흐름) : 화살표
* Data Store(자료 저장소) : 평행선
* Terminator(단말) : 사각형

## 객체지향(Object-Oriented)
* Object(객체)
* Class(클래스)
    
    공통된 송성과 연상(행위)를 갖는 객체의 집합

    데이터를 추상화하는 단위

* Encapsulation(캡슐화)

    데이터(속성)와 데이터를 처리하는 함수를 하나로 묶은 것

    정보 은닉(은폐)되어 외부에서의 접근을 제한적이기 때문에 변경으로 인한 파급 효과가 적음


* Inheritance(상속)

    상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것

* Polymorphism(다형성)
* Relationship(연관셩)

## 객체지향 분석 및 설계
## 객체지향 분석 방법론
* Rumbaugh Method(럼바우 방법)

    OMT(객체 모델링 기법)

    <b>객체 모델링 → 동적 모델링 → 기능 모델링</b>

* Booch Method(부치 방법)
* Jacobson Method
* Coad and Yourdon Method

    E-R 다이어그램을 사용해 객체의 행위를 모델링

    객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성하는 기법

* Wirfs-Brock Method

## 모듈(Module)
모듈화를 통해 분리된 시스템의 각 기능

단독으로 컴파일 가능, 재사용 가능

모듈의 기능적 독립성 = SW를 구성하는 각 모듈의 기능이 서로 독립된 것

독립성이 높을 수록 수정 시 다른 모듈에 거의 영향을 미치지 않음

독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정

> 독립성 ↑ = 결합도 ↓,응집도 ↑, 모듈 크기 작게

### 결합도(Coupling)
모듈 간의 상호 의존하는 정도 / 두 모듈 사이의 연관 관계

결합도 ↓ = 품질 ↑  /  결합도 ↑ = 품질 ↓

<b>자료 < 스탬프 < 제어 < 외부 < 공통 < 내용</b>

### 응집도(Cohesion)
정보 은닉 개념을 확장한 것

모듈이 독럽적인 기능으로 정의되어 있는 정도

응집도 ↑ = 품질 ↑  /  응집도 ↓ = 품질 ↓

<b>기능 < 순차적 < 교환적 < 절차적 < 시간적 < 논리적 < 우연적</b>

## 디자인 패턴
자주 발생하는 문제에 대한 일반적이고 반복적인 해결방법
GoF(Gang of Four)라는 불리는 4명의 인물들이 처음으로 구체화 및 체계화함

### GoF 디자인 패턴 유형 
* 생성 패턴
    * 추상 팩토리(Abstract Factory)
    * 프로토타입(Prototype)
    * 팩토리 메소드(Factory Method)
    * 빌더(Builder)
    * 싱글톤(Singleton)
* 구조 패턴
    * 컴퍼지트(Composite)
    * 어댑터(Adapter)
    * 브리지(Bridge)
    * 프록시(Proxy)
* 행위 패턴
    * 옵서버(Observer)
    * 커맨드(Command)
    * 상태(State)
    * 방문자(Visitor)