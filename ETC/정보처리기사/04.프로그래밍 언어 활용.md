<details> 
    <summary>목차 </summary>
        <ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#c%EC%96%B8%EC%96%B4-%ED%91%9C%EC%A4%80-%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%95%A8%EC%88%98">C언어 표준 입/출력 함수</a></li>
                <ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#sacnf">sacnf()</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#printf">printf()</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EA%B8%B0%ED%83%80-%ED%91%9C%EC%A4%80-%EC%9E%85%EC%B6%9C%EB%A0%A5-%ED%95%A8%EC%88%98">기타 표준 입/출력 함수</a></li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EC%A0%9C%EC%96%B4%EB%AC%B8">제어문</a></li>
                <ul>   
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EB%8B%A8%EC%88%9C-if%EB%AC%B8">단순 if문</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EB%8B%A4%EC%A4%91-if%EB%AC%B8">다중 if문</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#switch%EB%AC%B8">switch문</a></li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#unix">UNIX</a></li>
                <ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#unix-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%84%B1">UNIX 시스템 구성</a></li>
                </ul>
            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98">기억장치</a></li>
                <ul>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0-%ED%8A%B9%EC%A7%95">기억장치 계층 구조 특징</a></li>
                    <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5">기억 장치 관리 전략</a></li>
                        <ul>
                            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EB%B0%98%EC%9E%85fetch-%EC%A0%84%EB%9E%B5">반입(Fetch) 전략</a></li>
                            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EB%B0%B0%EC%B9%98placement-%EC%A0%84%EB%9E%B5">배치(Placement) 전략</a></li>
                            <li><a href="https://github.com/elilly00/TIL/blob/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/04.%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9.md#%EA%B5%90%EC%B2%B4replaccement-%EC%A0%84%EB%9E%B5">교체(Replaccement) 전략</a></li>
                        </ul>
                </ul>
        </ul>
</details>
<div markdown="1">

## C언어 표준 입/출력 함수
### sacnf()
키보드로 입력받아 변수에 저장하는 함수 (Java에서 Scanner와 동일함)

<b>scanf(서식 문자열, 변수의 주소)</b>
    
    scnaf("%3d", &a);
    % : 서식 문자임을 지정
    3 : 입력 자릿수를 3자리로 지정
    d : 10진수로 입력
    &a : 입력받은 데이터를 변수 a의 주소에 저장

#### 특징
* 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다.
* 한 번에 여러 개의 데이터를 입력 받을 수 있다.
* 서식 문자열과 변수의 자료형은 일치해야 한다.
#### 서식 문자열
서식 문자열은 prinf() 함수로 출력할 때도 동일하게 적용된다.
|서식 문자열|의미|
|---------|-----|
|%d|정수형 10진수 입/출력|
|%u|부호없는 정수형 10진수 입/출력|
|%o|정수형 8진수 입/출력|
|%x|정수형 16진수 입/출력|
|%c|문자 입/출력|
|%s|문자열 입/출력|
|%f|소수점 포함하는 실수 입/출력|
|%e|지수형 실수 입/출력|
|%ld|long형 10진수 입/출력|
|%lo|long형 8진수 입/출력|
|%lx|long형 16진수 입/출력|
|%p|주소를 16진수 입/출력|

### printf()
인수로 주어진 값을 화면에 출력하는 함수

<b>printf(서식 문자열, 변수)</b>

    pringf("%-8.2f:, 200.2);
    % : 서식 문자임을 지정
    - : 왼쪽부터 출력
    8 : 출력 자릿수를 8자리로 지정
    2 : 소수점 이하를 2자리로 지정
    f : 실수로 출력

#### 주요 제어문자
|문자|의미|가눙|
|----|----|-----|
|\n |new line |다음 줄 앞으로 이동 |
|\b |backspace |왼쪽으로 한 칸 이동 |
|\t |tab |일정 간격 띄움 |
|\r |carriage return |현재 줄의 처음으로 이동 |
|\0 |null |null 문자 출력 |
|\' |single quote |작은따옴표 출력 |
|\" |double quote |큰따옴표 출력 |
|\a |alert |스피커로 벨 소리 출력 |
|\\\ |backslash |역 슬래시 출력 |
|\f |form feed |한 페이지 넘김 |

### 기타 표준 입/출력 함수
* 입력
    
    getchar() : 키보드로 한 문자를 입력받아 변수에 저장
    
    gets() : 키보드로 문자열을 입력받아 변수에 저장하는 함수, 'Enter'를 누르기 전까지를 하나의 문자열로 인식해 저장

* 출력

    putchar() : 인수로 주어진 한 문자를 화면에 출력

    puts() : 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동

## 제어문

<b>#includ <stdio.h> </b>

C 표준 라이브러리 중 하나인 stdo.h라는 헤더 파일에 선언된 내용을 포함한다는 의미이다. 이 문장을 쓰지 않으면, printf 함수의 선언을 찾을 수 없다는 컴파일 오류가 발생한다.

### 단순 if문
#### 조건이 참일 때

    [Java]
    if(조건)
    실행할 문장;
    ------------
    if(조건) {
        실행할 문장1;
        실행할 문자2;
        ⁝
    }
    -------------------------------------------------------
    [C]
    #include <stdio.h>
    main() {
        int a = 15, b;
        if(a > 10)          -> a가 10보다 크면 1번 문장 실행, 아니면 2번 문장 실행
        b = a - 10;         // 1 
        printf("%d\n", b);  // 2  -> 조건식이 거짓일 경우 실행할 문장이 없다. 조건 판단문을 벗어나면 무조건 출력함수로 온다.
    }

#### 조건이 참이거나 거짓일 때

    [Java]
    if(조건)
        실행할 문장1;   // 참일 때 실행
    else 
        실행할 문장2;   // 거짓일 때 실행
    -------------------------------------------------------
    [C]
    #includ <stdio.h>
    main() {
        int a = 10, b = 20, cha;
        if(a > b)
            cha = a - b;
        else 
            cha = b - a;
        printf("%d\n", cha);
    }
    
### 다중 if문
#### 조건이 여러개 일 때

    [Java]
    if(조건1)
        실행할 문장1;
    else if(조건2)
        실행할 문장2;
    else if(조건3)
        실행할 문장3;
            ⁝
    else
        실행할 문장4;   // 앞의 조건이 모두 거짓일 때 실행
    -------------------------------------------------------
    [C]
    #include <stdio.h>
    main() {
        int jum = x;
        if(jum >= 90)   -> jum이 90이상이면 문장을 출력하고, 아니라면 다음 조건문으로 넘어간다.
            printf("학점은 A입니다.\n");
        else if(jum >= 80)
            printf("학점은 B입니다.\n");
        else if(jum >= 70)
            printf("학점은 C입니다.\n");
        else 
            printf("학점은 F입니다.\n);
    }

### Switch문
조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문

    [Java]
    switch(수식) {
        case 레이블1:
            실행할 문장1;
            break;
        case 레이블2:
            실행할 문장2;
            break;
        case 레이블3:
            실행할 문장3;
            break;
              ⁝
        default:
            실행할 문장4;
    }
    -------------------------------------------------------
    [C]
    #include <stdio.h>
    main() {
        int jum = x;
        switch(jum / 10) {
            case 10:

            case 9:
                printf("학점은 A입니다.\n");
                break;
            case 8:
                printf("학점은 B입니다.\n");
                break;
            case 7:
                printf("학점은 C입니다.\n");
                break;
            case 6:
                printf("학점은 D입니다.\n");
                break;
            default:
                printf("학점은 F입니다.\n");
        }
    }

## UNIX
* UNIX는 C언어로 작성되어 있어 이식성이 높고 장치, 프로세스 간의 호환성이 높다.

* 크기가 작고 이해하기 쉽다.

* 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다. 
(하나 이상의 작업을 백그라운드에서 수행해 여러 작업을 동시에 처리할 수 있다.)

* 많은 네트워킹 기능을 제공해 통신망(Network) 관리용 운영체제로 적합하다.

* 트리 구조의 파일 시스템을 갖는다.

* 전문적인 프로그램 개발에 용이하다.

* 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System)이다.

### UNIX 시스템 구성
    하드웨어 < 커널(Kernel) < 쉘(Shell) < 유틸리티(Utility) < 사용자(User)

#### 커널(Kernel)
UNIX의 가장 핵심적인 부분으로 컴퓨터가 부팅됭 때 주기억장치에 적재된 후 상주하면서 실행된다.

하드웨어 보호, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다.

프로세스(CPU 스케줄링)관리, 기억장치 관리, 파일 관리, 입/출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등의 기능을 수행한다.

#### 쉘(Shell)
사용자의 명령어를 인식해 프로그램을 호출하고 명령을 수행하는 명령어 해석기

시스템과 사용자간의 인터페이스 담당

주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재해 보조 기억장치에서 교체 처리가 가능하다.

파이프라인 기능 지원, 입/출력 재지정을 통해 출력과 입력 방향을 변경할 수 있다.


공용 쉘이나 사용자가 만든 쉘을 사용할 수 있다.

#### Utility Program
일반 사용자가 작성한 응용 프로그램을 처리한다.

에디터, 컴파일러, 인터프리터, 디버거 등이 있다.

## 기억장치
### 기억장치 계층 구조 특징

![기억장치 계층 구조](https://user-images.githubusercontent.com/90914001/177004999-edbb3c3b-c12b-4579-ae51-082b342f4a80.PNG)

* 상위 기억장치일수록 접근 속도와 접근 시간이 빠르지만 기억 용량이 적고 고가이다.

* 주기억장치

    각기 자신의 주소를 갖는 워드/바이트들로 구성, 주소를 이용해 액세스 가능

* 레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터틑 CPU가 직접 액세스 할 수 있지만 보조기억장치에 있는 프로그램이나 데이터는 직접 액세스 할 수 없다.

* 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스될 수 있다.

### 기억 장치 관리 전략
보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시가, 적재 위치 등을 지정해 한정된 주기억장치의 공간을 효울적으로 사용하기 위한것으로 **반입(Fetch) 전략, 배치(Placement) 전략, 교체(Replacement) 전략**이 있다.

#### **반입(Fetch) 전략**
보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 배치할 것인지를 결정하는 전략

* **요구 반입(Demand Fetch)**
    
    실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

* **예상 반입(Anticipatory Fetch)**

    실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상해 적재하는 방법

#### **배치(Placement) 전략**
새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

* **최초 적합(First Fit)**

    프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 첫 번째 분할 영역에 배치시키는 방법

* **최적 적합(Best Fit)**

    프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법

* **최악 적합(Worst Fit)**

    프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법


#### **교체(Replaccement) 전략**
주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램/데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체해 사용할 것인지 결정하는 전략

* FIFO, OPT, LRU, LFU, NUR, SCR etc..




<a href="#" class="btn--success">⇑ 맨위로 이동</a>
